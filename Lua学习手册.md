# Lua学习手册

[TOC]

## 第一章

1. 先运行程序块，再进入交互界面：`lua  -i prog`

2. 交互模式中立刻执行代码块(加载程序库)：`dofile("lib1.lua")`

   可以采用两个窗口，一个修改代码文件，一个用来测试运行

3. 特殊变量：下划线+大写字母开头（例：_ABC）

4. Lua区分大小写

5. 注释：

   ​	行注释 --

   ​	块注释 --[[   

   ​					注释内容  

   ​				]]

6. 全局变量不需要声明，全局变量必定有值

   全局变量赋初值，例：a=nil

7. lua脚本遵循脚本代码的编写原则

   开始行：`#!/bin/lua`

8. 

### 解释器程序的用法

- lua [选项参数] [脚本[参数]]
- 无参数启动解释器将直接进入交互模式
- -e 可以直接在命令行中输入代码，例：`lua -e print(sin(12))`
- -i 运行完其他命令行参数后直接进入交互模式
- -l 加载库文件，例：`lua -l a.lib`
- =表达式，可以打印任何表达式的值

## 第二章、类型与值

1. 函数type根据值返回其数据类型

2. nil用于表示没有任何有效值的情况

3. false和nil表示**假**，其他值表示**真**

4. 用double来表示number

5. lua的字符串类型值不可变，需要通过创建新的字符串来修改

6. lua通过自动内存管理机制来管理对象，无需分配和释放

7. lua的转义字符和c语言类似

8. ![image-20210701143401062](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210701143401062.png)

9. 用数字输出转义字符

   例：\\<049> 代表 字符数字1，因为1在ascii中值为49

10. 通过一对双方括号[[]]来界定字母字符串，双方括号互相匹配

    例如：[===[字符串内容]===]，[==[字符串内容]==]

    内嵌=号的字符串内容可以直接输出，不通过转义

11. 数字和字符串可能会相互转换

12.  .. 是字符串连接操作符，连接数字必须有一个空格，不然会被当成小数点

13. 字符串转换成数值，用函数tonumber();

14. 数值转换成字符串，用函数tostring();

15. 在字符串前放置#可以获取字符串长度，例：#abc ---> 3

16. table实现了关联数组（映射key-value），动态大小

    通过{}来构造表，例：a={}

17. 将nil赋值给对象会导致对象被回收

18. 可以通过成员符 . 引用对象，例如，a["x"]=3 等价于 a.x=3

19. 数组通常以 1 作为索引值的起始值

20. 长度操作符#可以返回数组或者线性表的大小

21. 长度操作符#会将作为结尾

22. Lua5.0不支持长度操作符，可以使用函数getn（Lua5.1的新函数）

23. table.maxn将返回table的最大正索引数

24. 在数据类型中，只有table是引用传递，其他的都是值传递

### Lua的基础数据类型

1. nil（空）
2. boolean（布尔）
3. number（数字）
4. string（字符串）
5. userdata（自定义数据类型）
6. function（函数）
7. thread（线程）
8. table（表）

## 第三章、表达式

### 关系操作符

- \> 大于
- \< 小于
- <= 小等于
- \>= 大等于
- == 相等
- ~= 不相等

### 逻辑操作符

- or（或）
- and（与）
- not（非）



1. 整数计算结果的符号永远与第二个参数相同

2. 不同类型的两个值是不相等的

3. nil只与其自身相等

4. 对于table、userdata和函数都是做引用比较，

   当只有是同一个对象时才会返回true

5. 只能对数值和字符串进行大小性比较

6. 字符串默认ascii码大的为大

   但是当区域设置为 EuropeanLatin-1 时，ascii码大的为小

7. 如果用 字符串连接符 .. 连接两个数字的话，会将两个数字转换成字符串

8. 因为字符串是不可变得值，所以连接操作只会创建一个新的字符串，而不会对原字符串进行修改。

9. 操作符的优先级表

   ![image-20210701195852556](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210701195852556.png)

10. 尽量用括号来确定优先级顺序

11. 构造式初始化数组，例：days={"A","B","C"};

    则days[1]="A",days[2]="B",days[3]="C";

12. 若是a={x=10,y=20},则 a.x=10, a.y=20;

13. 若没有指定关键字的值，则根据默认的索引下标继续往下标记

    例：a={x=10,y=20,333,444,555}，则a[1]=333,a[2]=444,a[3]=555;



## 第四章、语句

1. 多重赋值，例：a, b = 123, 456;

2. 若**变量个数**大于**参数个数**，则多余的变量被赋予nil

3. 若**变量个数**小于**参数个数**，则丢弃多余参数

4. 当函数有多个返回值时，可以通过多个变量多重赋值来接收

5. 用 local 来声明局部变量

6. 在交互模式中，每一行都相当于一个程序块

7. Lua不支持switch语句

8. 声明在循环体的局部变量，作用域包括测试条件

9. 数字型for循环的控制变量在循环开始前一次性求值，

   控制变量是循环的局部变量

10. ipairs用于遍历数组的迭代器函数

11. **table在用数组顺序存储的方式存储值，用哈希的方式存储键值对，ipairs只会遍历数组中的值，不会遍历哈希表，pairs先遍历数组，再遍历哈希表**

12. **table在存储key-value的时候，输出的时候从后往前，冲突顺序也是从后往前**

13. lua的for循环是闭区间

14. 只有在块结束的末尾才可以使用return

    否则在块中要使用return只能采用 do return XXX end 格式

15.  : 是一个语法糖，若采用 aa:func() 的方式，会自动把self作为第一个参数

    否则需要写成 aa.func(self,...) 的方式

16. 



- IF判断语句：

  if a<0 then 

  ​		XXXX

  else

  ​		XXXX

  end

- 多重嵌套的IF：

  if op==1 then

  ​		XXXX

  elseif op==2 then

  ​		XXXX

  elseif op==2 then

  ​		XXXX

  else 

  ​		XXXX

  end

- while循环语句（先判断，条件为真时循环，条件为假时结束）

  while XXXX do 

  ​		XXXX

  end

- repeat循环语句（先执行，条件为假时执行，条件为真时结束）

  repeat

  ​		XXXX

  until XXXX 

- 数组型for循环

  for i=1,10,2 do (三个参数分别代表：[起始值，终止值],步长 )

  ​		XXXX

  end

- 泛型for循环

  for i,v in ipairs(a) do (三个参数代表：索引值，索引的元素值，数组)

  ​		XXXX

  end

## 第五章、函数

1. 一个函数若只有一个**字符串**参数，则可以省略圆括号
2. 调用函数时，实参与形参数量不相等，遵循参数赋值的原则，实参不足则补nil，实参过多则去掉
3. 若函数是一个系列表达式的**最后一个元素**，则将尽可能地保留更多的返回值，若**不是最后一个参数**，则只保留一个返回值
4. table可以完整接受一个函数调用的所有结果
5. 函数调用若在一对圆括号中，则强制返回一个结果
6. unpack()可以返回一个数组所有的值
7. 表达式 ... 代表变长参数
8. select("#",...)会返回所有的变长参数，其中包括nil
9. select(n,...)会返回变长参数的第n个参数
10. 通过将实参改为table，可以通过成员调用的方式获取实际的具名参数，可以使函数操作更具体化
11. **函数内的局部变量不加local会被作为全局变量，参与全程递归**

## 第六章、深入函数

1. table.sort(table对象, 次序函数)

   用法：

   ​			student={  {id=1,  name="zhangsan"},  {id=2,  name="lisi"},   {id=3,   name="wangwu"}}

   ​			table.sort(  student ,  function(a,b)  return  (a.id<b.id)  end  )

2. closure的概念：函数会访问到某些“非局部变量”，即函数访问到了全局变量，类似于数据的封装性。

3. 函数存在table中

   法一：

   ​			lib={}

   ​			lib.foo = function ( x,y ) return x + y end

   ​			lib.goo = function ( x,y ) return x - y end

   法二：

   ​			lib = {

   ​			lib.foo = function ( x,y ) return x + y end

   ​			lib.goo = function ( x,y ) return x - y end

   ​			}

   法三：

   ​			lib={}

   ​			function lib.foo  ( x,y ) return x + y end

   ​			function lib.goo  ( x,y ) return x - y end

4. 将一个函数储存在局部变量中，可以使其他函数也调用这些局部函数。

   局部函数之间可以互相调用。

   local f = function(<参数>)

   ​		<函数体>

   end

   local g = function(<参数>)

   ​		<代码>

   ​		f()	--f()在此处是可见的，函数体之间可以互相调用

   ​		<代码>

   end

5. 采用展开“语法糖”的方式定义递归函数，来避免发生错误

   local foo

   foo = function (<参数>) <函数体> end

   或者

   local function fact( n )

   ​		if n==0 then return 1

   ​		else return n * fact( n-1 )

   ​		end

   end

6. 间接递归的方式必须提前声明local function g , f

7. 尾调用实际上只是完成了一条goto，而不是传统意义上的函数调用，所以不会产生**栈溢出**的问题

   

   



## 第七章、迭代器与泛型for

1. 
2. 

## _G

1. \_G是一个变量，数据类型是table。_G保存了所有的全局变量和全局函数。初始情况只包含lua程序库的函数和变量。
2. 在lua中定义的全局函数和变量都会自动添加到\_G中。
3. 可以把局部的函数用键值对的方式保存在\_G中，这样子就可以通过\_G和键来访问原来的局部函数了。









## 表

表的插入：table.insert(list, [pos, ]value)，若没有指定位置默认在表尾插入

表的删除：table.remove(list[, pos])，若没有指定位置默认删除表尾。遍历删除表					的时候请**从后往前**依次遍历删除，避免漏删。

Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:

- 1.在表中查找，如果找到，返回该元素，找不到则继续
- 2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。
- 3.判断元表有没有 \__index 方法，如果 \__index 方法为 nil，则返回 nil；如果 \__index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。



\_\_newindex元方法用来对表进行更新，\_\_index则用来对元表进行访问



## io文件的读写

1. io.open(file_path,"r")的模式要求文件必须存在，所以可以通过这种方式判断文件是否存在。
